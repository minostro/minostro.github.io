---
layout: post
title: "Meaculpa's: A Distributed Point of Sales System Built in Django"
date: 2017-05-29 12:49:00
tag:
- Django
- Python
- JavaScript
projects: true
---
## Overview
Meaculpa's is a Distributed Point of Sales System built for the biggest liquor store chain located in the North of Chile. The design of Meaculpa's system is divided into two major subsystems: *branch* and *central*. *branch* (the point of sales) is the transactional system that processes product sales, product returns, and manages the inventory of the products locally. Currently, there are 5 branches (real liquor stores) in operation. *central* is the admin system that manages the products, providers, orders, and product inventory company wise. *central* is also responsible for holding all the transactional data generated by the branches, so the owners and managers can generate reports and make strategical decisions with them.

## Key Features
* The communication between *branch* and *central* is **asynchronous**. *branch* **polls** from *central* for data updates and **pushes** transactional data into *central*.
* *branch* is designed in such a way that it can operates **without having** Internet connection. Yes! this means that it **does not** require to have connectivity with *central* to operate.
* *branch* can be accessed **remotely** by the managers to update inventory quantities.
* *central* **automatically** creates orders for branches that are running out of inventory.

## Logical Diagram
### Branch Subsystem
![Branch Logical Diagram](/assets/images/projects/meaculpas/branch_logical_diagram.png)

The subsystem has three main modules:
#### Admin
This module allows owners/managers of the store to keep track of the inventory and modify it if necessary. This is required sometimes as a result of performing a Random Sample Cycle Counting. This module also allows shop assistance to receive new inventory coming from the warehouse.

#### Synchronization
This module is in charge of keeping in sync the *branch* with *master* and also to push transactional data from *branch* to *master*. There is a cron job running which kicks off these processes.

#### Product Sales
This is the main module that the shop assistants use to sale products.

![Branch Sales UI](/assets/images/projects/meaculpas/branch_sales_ui.png)

### Central Subsystem
![Central Logical Diagram](/assets/images/projects/meaculpas/central_logical_diagram.png)

The subsystem has three main modules:
#### Synchronization
This module is in charge of keeping track of any changes of the objects that the *branch* is interested. This module also exposes a Restful API so the *branch* can get these data updates and also can pushes the transactional information.

#### Invoicing
This module is in charge of generating the invoices related to any sales that happen at the warehouse. This module was first interacting with matrix point printers and then it got changed to interact with the Chilean Internal Revenue Service to generate digital invoice documents.

#### Reporting
This module is in charge of generating all the reports that the upper management needs to see how the business is performing. The reports were at first were generated in a synchronous fashion, but as the volume of data increased, the reports needed to be generated in an asynchronous fashion.

#### Admin
![Central UI](/assets/images/projects/meaculpas/central_ui.png)
This module is meant to be used by the owners/managers to CRUD[^1] products, providers, store assistants, orders among others.

[^1]: https://en.wikipedia.org/wiki/Create,_read,_update_and_delete


## Software Stack
* Python 2.7
* Django 1.10
* PostgreSQL 9.5
* JQuery
* JQueryUI

## Learnings/Challenges
* Working for a couple of shifts in the liquor stores, helped me on understanding the nature and dynamics of the bussines. This influenced the developement of the UI. Learnings from a pass project [AlyMoly](http://www.minostro.com/alymoly/) were applied when developing the UI for the shop assistants.
* Asynchronous communication between *branch* and *central*, and *branch* being able to hold local state proved to be a huge win.  The legacy system that was replaced by this new system, required *branch* to have connectivity with *central* at all times. This was not a reasonable approach because the liquor stores usually lose internet connectivity.
* Adding a link to the last recorded sales was useful for the shop assistants whenever the computer was accidentally turned-off or rebooted.
* The sales of the products were recorded at the unit level. This idea is natural and makes sense. Soon after going live with the branch system, the team realized that this was problematic when selling products that came in packs. An example of this are beers; a 6 pack of duff beer. The shop assistants needed to scan one unit (a duff beer) and then increase the quantity to 6. This was suboptimal considering that all packs have a barcode and we knew up front the quantity of inventory they had. I came up with the idea of defining a new abstraction called *proxy* product. A proxy product holds two important piece of information: the product of the unit, and how many units of that product it has. With this abstraction in place, the shop assistants could just scan the barcode of the pack and be done with it. A proxy product differs from a regular product in that a proxy product does not hold real inventory. The inventory decreases at its product unit level.
* At the end of the project, I realized that a couple of features that were implemented were not used at all. I think this showed a lack of prioritization about which features were more important than others.

## Role
I implemented the UI as well as part of the modules/classes in the Backend Service for the *branch* and *central* systems. I was the engineer in charge of gathering the requirements from the owners/managers of the business. I worked on this project with [Andrés Otárola](https://github.com/aotarola). We were the only engineers working on this project.
